<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Anki - Card-reveal Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Don't use this in production: -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <style>
      table {
        border-collapse: collapse;
      }
      tbody {
        border-bottom: 2px solid gray;
      }
      tbody:last-of-type {
        border-bottom: none;
      }
      .reveal-container {
        overflow: hidden;
      }
      /* Highlight styles */
      .reveal-container .reveal.selected {
        border: 5px solid rgba(0, 0, 255, 0.25);
        border-radius: 5px;
        z-index: 99;
      }
      .reveal-container .reveal.highlighted {
        border: 5px solid rgba(255, 0, 0, 0.25);
        border-radius: 5px;
        z-index: 100;
      }
      .reveal.highlighted.drag * { cursor: move; }
      .reveal.highlighted.resize-n, .reveal.highlighted.resize-n *, .reveal.highlighted.resize-s, .reveal.highlighted.resize-s * { cursor: ns-resize; }
      .reveal.highlighted.resize-e, .reveal.highlighted.resize-e *, .reveal.highlighted.resize-w, .reveal.highlighted.resize-w * { cursor: ew-resize; }
      .reveal.highlighted.resize-ne, .reveal.highlighted.resize-ne *, .reveal.highlighted.resize-sw, .reveal.highlighted.resize-sw * { cursor: nesw-resize; }
      .reveal.highlighted.resize-nw, .reveal.highlighted.resize-nw *, .reveal.highlighted.resize-se, .reveal.highlighted.resize-se * { cursor: nwse-resize; }
      
      .reveal-container:not(.centered) .reveal.selected:not(.centered),
      .reveal-container.centered .reveal.selected.not-centered,
      .reveal-container:not(.centered) .reveal.highlighted:not(.centered),
      .reveal-container.centered .reveal.highlighted.not-centered {
          transform: translateX(-5px) translateY(-5px);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      /* React components */

      /**
       * Toolbar component
       */
      function Toolbar({ onReset, onExport }) {
        return (
          <div>
            <button onClick={onReset}>Reset</button>
            <button onClick={onExport}>Export to Clipboard</button>
          </div>
        );
      }

      /**
       * Table editor entry component
       */
      function TableEditorEntry({ id, selected, highlighted, label, content, posX, posY, width, height, onChange, onHighlight }) {
        return (
          <tr onMouseEnter={() => onHighlight(true)} onMouseLeave={() => onHighlight(false)}>
            <td><input type="checkbox" checked={selected} onChange={(e) => onChange(id, 'selected', e.target.checked)} /></td>
            <td><input type="text" value={label} onChange={(e) => onChange(id, 'label', e.target.value)} /></td>
            <td><input type="text" value={content} onChange={(e) => onChange(id, 'content', e.target.value)} /></td>
            <td><input type="text" value={posX} onChange={(e) => onChange(id, 'posX', e.target.value)} /></td>
            <td><input type="text" value={posY} onChange={(e) => onChange(id, 'posY', e.target.value)} /></td>
            <td><input type="text" value={width} onChange={(e) => onChange(id, 'width', e.target.value)} /></td>
            <td><input type="text" value={height} onChange={(e) => onChange(id, 'height', e.target.value)} /></td>
          </tr>
        );
      }

      /**
       * Config component
       */
      function Config({ config }) {
        const handleFileUpload = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
              config.setBackgroundImage(reader.result);
            };
            reader.readAsDataURL(file);
          }
        };

        return (
          <div>
            <h2>Config</h2>
            <div>
              <label>
                Background Image:
                <input type="file" accept="image/*" onChange={handleFileUpload} />
              </label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.reversible} onChange={(e) => config.setReversible(e.target.checked)} /> Reversible</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.centered} onChange={(e) => config.setCentered(e.target.checked)} /> Centered</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.hideable} onChange={(e) => config.setHideable(e.target.checked)} /> Hideable</label> - <span>once revealed, content can be hidden</span>
            </div>
          </div>
        );
      }

      /**
       * Table editor component
       */
      function TableEditor({ entries, onChange, onAddEntry, onGroupEntries, onIsolateEntries, onMoveUp, onMoveDown, onRemoveEntries }) {
        const [selectAllChecked, setSelectAllChecked] = React.useState(false);
        const [selectAllIndeterminate, setSelectAllIndeterminate] = React.useState(false);

        const handleSelectAll = (e) => {
          const checked = e.target.checked;
          setSelectAllChecked(checked);
          setSelectAllIndeterminate(false);
          entries.forEach((group, groupIndex) => {
            group.forEach((entry, entryIndex) => {
              onChange(`${groupIndex}-${entryIndex}`, 'selected', checked);
            });
          });
        };

        const handleHighlight = (id, value) => onChange(id, 'highlighted', value);

        React.useEffect(() => {
          const totalEntries = entries.flat().length;
          const selectedEntries = entries.flat().filter(entry => entry.selected).length;

          if (selectedEntries === 0) {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(false);
          } else if (selectedEntries === totalEntries) {
            setSelectAllChecked(true);
            setSelectAllIndeterminate(false);
          } else {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(true);
          }
        }, [entries]);

        return (
          <div>
            <h2>Entries</h2>
            <table>
              <thead>
                <tr>
                  <th>
                    <input
                      type="checkbox"
                      checked={selectAllChecked}
                      ref={el => el && (el.indeterminate = selectAllIndeterminate)}
                      onChange={handleSelectAll}
                    />
                  </th>
                  <th>Label</th>
                  <th>Content</th>
                  <th>PosX (%)</th>
                  <th>PosY (%)</th>
                  <th>Width (%)</th>
                  <th>Height (%)</th>
                </tr>
              </thead>
              {entries.map((entry, groupIndex) => (
                <tbody key={groupIndex}>
                  {entry.map((entry, index) => (
                    <TableEditorEntry
                      key={index}
                      id={`${groupIndex}-${index}`}
                      {...entry}
                      onChange={onChange}
                      onHighlight={(value) => handleHighlight(`${groupIndex}-${index}`, value)}
                    />
                  ))}
                </tbody>
              ))}
              <tfoot>
                <tr><td colSpan="8">
                  <span>{entries.flat().filter(entry => entry.selected).length} rows selected - </span>
                  <button onClick={onGroupEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Group</button>
                  <button onClick={onIsolateEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Isolate</button>

                  <button onClick={onMoveUp} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Move Up</button>
                  <button onClick={onMoveDown} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Move Down</button>

                  <button onClick={onRemoveEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Remove</button>

                  <button onClick={onAddEntry}>Add</button>
                </td></tr>
              </tfoot>
            </table>
          </div>
        );
      }

      /**
       * Generate options string from config
       */
      function generateOptionsString(config) {
        return ['reversible', 'centered', 'hideable'].filter(option => config[option]).join(' ');
      }

      /**
       * Visual editor component
       */
      function VisualEditor({ entries, config, htmlContent, onEntryUpdate }) {
        // Raw CSS used by advanced reveal features
        const revealCSS = `
          /****** REVEAL FUNCTIONALITY ******/
          /* USAGE

          - Add an image with class "reveal-background":

          <img class="reveal-background" src="{{Src}}">

          - For each reveal element, add the following HTML:

          <div class="reveal {{hint round border centered}}" style="top: {{Top}}; left: {{Left}}; height: {{Height}}; width: {{Width}};">
            <input id="{{ID}}" type="checkbox"></input>
            <label for="{{ID}}">{{Label}}</label>
            <div>{{Content}}</div>
          </div>

          - A generator is available at https://docs.google.com/spreadsheets/d/10xOEICIvBzzAa8FtoUb2MYhJlJLE-AfpuX9IoUlIQ0I/edit?usp=sharing

          - If not used in a reveal card type, manually add the following HTML around reveal items:

          <div class="reveal-container {{revealed centered reversible hideable front/back-gradient/transparent front/back-text-white/red}}">{...}</div>

          */

          .reveal-container {
              position: relative;
              margin: 0;
              padding: 0;
              user-select: none;
          }

          .reveal-container .reveal-background {
              display: block;
              width: 100%;
              height: auto;
          }
          .reveal-container img.reveal-background {
              max-width: 100%;
          }

          .reveal-container > :not(.reveal-background):not(.reveal-sequencing):not(.reveal) {
              display: none;
          }

          .reveal-container .reveal {
              position: absolute;
              margin: 0;
              padding: 0;
              z-index: 1;
          }

          .reveal-container .reveal > input {
              margin-left:-99999px;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div
          {
              display: flex;
              position: absolute;
              top: 0;
              left: 0;
              height: 100%;
              width: 100%;
              z-index: 1;
          }

          /* NOT CHECKED */

          .reveal-container:not(.revealed) .reveal:not(.revealed) > input:not(:checked) + label + div,
          .reveal-container .reveal.revealed > input:checked + label + div,
          .reveal-container.revealed .reveal > input:checked + label + div
          {
              display: none;
          }

          /* CHECKED or REVEALED */

          .reveal-container:not(.revealed) .reveal:not(.revealed) > input:checked + label,
          .reveal-container .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked) + label
          {
              opacity: 0;
          }

          .reveal-container:not(.revealed) .reveal:not(.revealed) .on-reveal {
            display: none;
          }

          /* DEFAULT LOOK */

          .reveal-container .reveal * {
              box-sizing: border-box;
              -moz-box-sizing: border-box;
              -webkit-box-sizing: border-box;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div {
              outline: none;
              justify-content: center;
              align-items: center;
              text-align: center;
              font-size: 2.5vw;
              background: white;
              border: none;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div,
          .reveal-container .reveal > input + label.text-black,
          .reveal-container .reveal.front-text-black > input + label,
          .reveal-container.front-text-black .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-black,
          .reveal-container .reveal.back-text-black > input + label + div,
          .reveal-container.back-text-black .reveal > input + label + div
          {
              color: black;
              text-shadow: -1px -1px 1px white, 1px -1px 1px white, -1px 1px 1px white, 1px 1px 1px white;
          }

          /* ADDITIONAL LOOKS */
          .reveal-container .reveal > input + label.gradient,
          .reveal-container .reveal.front-gradient > input + label,
          .reveal-container.front-gradient .reveal > input + label,
          .reveal-container .reveal > input + label + div.gradient,
          .reveal-container .reveal.back-gradient > input + label + div,
          .reveal-container.back-gradient .reveal > input + label + div
          {
              background: radial-gradient(circle, white, transparent);
              border: none;
          }

          .reveal-container .reveal > input + label.transparent,
          .reveal-container .reveal.front-transparent > input + label,
          .reveal-container.front-transparent .reveal > input + label,
          .reveal-container .reveal > input + label + div.transparent,
          .reveal-container .reveal.back-transparent > input + label + div,
          .reveal-container.back-transparent .reveal > input + label + div
          {
              background: transparent;
              border: none;
          }

          .reveal-container .reveal > input + label.text-white,
          .reveal-container .reveal.front-text-white > input + label,
          .reveal-container.front-text-white .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-white,
          .reveal-container .reveal.back-text-white > input + label + div,
          .reveal-container.back-text-white .reveal > input + label + div
          {
              color: white;
              text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
          }

          .reveal-container .reveal > input + label.text-red,
          .reveal-container .reveal.front-text-red > input + label,
          .reveal-container.front-text-red .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-red,
          .reveal-container .reveal.back-text-red > input + label + div,
          .reveal-container.back-text-red .reveal > input + label + div
          {
              color: red;
              text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
          }

          /* CENTERED feature */

          .reveal-container .reveal.centered,
          .reveal-container.centered .reveal:not(.not-centered)
          {
              transform: translateX(-50%) translateY(-50%);
          }

          /* SEQUENCING feature */

          .reveal-container .reveal-sequencing {
            background: transparent;
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 100%;
            z-index: 1;
            display: none;
          }

          .reveal-container:not(.revealed) .reveal-sequencing:has(~ .reveal:not(.revealed) > input:not(:checked) + label)
          {
            display: block;
          }

          /* REVERSIBLE feature */

          .reveal-container .reveal > input:checked + label.reversible,
          .reveal-container .reveal.reversible > input:checked + label,
          .reveal-container.reversible .reveal > input:checked + label,
          .reveal-container .reveal.revealed > input:not(:checked)+ label.reversible,
          .reveal-container .reveal.revealed.reversible > input:not(:checked) + label,
          .reveal-container.reversible .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked)+ label.reversible,
          .reveal-container.revealed .reveal.reversible > input:not(:checked) + label,
          .reveal-container.revealed.reversible .reveal > input:not(:checked) + label
          {
              z-index: 2;
          }

          /* HIDEABLE feature */

          .reveal-container .reveal.revealed > input:not(:checked)+ label.hideable,
          .reveal-container .reveal.revealed.hideable > input:not(:checked) + label,
          .reveal-container.hideable .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked)+ label.hideable,
          .reveal-container.revealed .reveal.hideable > input:not(:checked) + label,
          .reveal-container.revealed.hideable .reveal > input:not(:checked) + label
          {
              z-index: 2;
          }

          .reveal-container .reveal.revealed > input:checked + label.hideable,
          .reveal-container.revealed .reveal > input:checked + label.hideable,
          .reveal-container .reveal.revealed.hideable > input:checked + label,
          .reveal-container.revealed .reveal.hideable > input:checked + label,
          .reveal-container.hideable .reveal.revealed > input:checked + label,
          .reveal-container.revealed.hideable .reveal > input:checked + label
          {
              opacity: 0;
          }
        `;
        const [revealed, setRevealed] = React.useState(false);
        const [highlightedElement, setHighlightedElement] = React.useState(null);
        const [snapToGrid, setSnapToGrid] = React.useState({gridSize: 1, decimals: 0});

        const clamp = (x, min, max) => Math.max(0, Math.min(100, x));

        const getMousePosition = (e, ref) => {
          const rect = ref.getBoundingClientRect();
          const distances = {
            left: e.clientX - rect.left - e.target.clientLeft,
            right: rect.left - e.target.clientLeft + rect.width - e.clientX,
            top: e.clientY - rect.top - e.target.clientTop,
            bottom: rect.top - e.target.clientTop + rect.height - e.clientY,
          };
          return {
            e,
            ref,
            x: clamp(distances.left/rect.width*100, 0, 100),
            y: clamp(distances.top/rect.height*100, 0, 100),
            ...distances,
          };
        };

        const getElementCapability = (e, target) => {
          const mouseElementPosition = getMousePosition(e, target);
          
          const border = Object.entries({
            n: mouseElementPosition.top <= 5,
            s: mouseElementPosition.bottom <= 5,
            e: mouseElementPosition.right <= 5,
            w: mouseElementPosition.left <= 5,
          }).filter(b => b[1]).map(b => b[0]).join('');

          return border.length ? 'resize-' + border : 'drag';
        };

        const handleMouseEnter = (e, entryId, entry, ref) => {
          const newHighlightedElement = { entryId, entry, target: e.target, ref, position: null, size: null, capability: null };
          setHighlightedElement(prevHighlightedElement => prevHighlightedElement?.action ? prevHighlightedElement : newHighlightedElement); // Handle previous helement here
        };

        const handleMouseLeave = () => {
          setHighlightedElement(prevHighlightedElement => prevHighlightedElement?.action ? prevHighlightedElement : null);
        };

        const handleMouseDown = (e, entryId, entry, ref) => {
          if (!highlightedElement) return;

          const position = { x: parseFloat(entry.posX), y: parseFloat(entry.posY) };
          const size = { width: parseFloat(entry.width), height: parseFloat(entry.height) };
          const capability = highlightedElement.capability;
          
          if (capability == 'drag' && !highlightedElement.action) {
            const newAction = { action: 'drag', position, size, mousePosition: getMousePosition(e, ref) };
            setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, ...newAction} : null); // TODO: No need for entryId and entry...
          }

          if (capability.startsWith('resize-')) {
            const newAction = { action: 'resize', position, size, direction: capability.split('-').pop(), mousePosition: getMousePosition(e, ref) };
            setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, ...newAction} : null); // TODO: No need for entryId and entry...
          }
        };

        const handleMouseMove = (e) => {
          if (!highlightedElement) return;

          // Update capability
          const capability = getElementCapability(e, highlightedElement.target);
          setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, capability} : null);
          
          if (highlightedElement.action === 'drag') {
            const mousePosition = getMousePosition(e, highlightedElement.ref);
            const diff = { x: mousePosition.x - highlightedElement.mousePosition.x, y: mousePosition.y - highlightedElement.mousePosition.y };
            const newPosition = {
              x: roundToGrid(highlightedElement.position.x + diff.x),
              y: roundToGrid(highlightedElement.position.y + diff.y),
            };

            onEntryUpdate(highlightedElement.entryId, { posX: newPosition.x.toFixed(snapToGrid.decimals), posY: newPosition.y.toFixed(snapToGrid.decimals) });
          }

          if (highlightedElement.action === 'resize') {
            const mousePosition = getMousePosition(e, highlightedElement.ref);
            const diff = { x: mousePosition.x - highlightedElement.mousePosition.x, y: mousePosition.y - highlightedElement.mousePosition.y };
            const newPosition = {...highlightedElement.position};
            const newSize = {...highlightedElement.size};
            const resizeMultiplier = config.centered ? 2 : 1;
            const direction = highlightedElement.direction;

            if (direction.includes('n')) {
              newSize.height = roundToGrid(highlightedElement.size.height - diff.y * resizeMultiplier); // Improve roundToGrid
              if (!config.centered) {
                newPosition.y = roundToGrid(highlightedElement.position.y + Math.min(diff.y, highlightedElement.size.height));
              }
            }
            if (direction.includes('s')) {
              newSize.height = roundToGrid(highlightedElement.size.height + diff.y * resizeMultiplier); // Improve roundToGrid
            }
            if (direction.includes('e')) {
              newSize.width = roundToGrid(highlightedElement.size.width + diff.x * resizeMultiplier); // TODO: Improve roundToGrid
            }
            if (direction.includes('w')) {
              newSize.width = roundToGrid(highlightedElement.size.width - diff.x * resizeMultiplier); // TODO: Improve roundToGrid
              if (!config.centered) {
                newPosition.x = roundToGrid(highlightedElement.position.x + Math.min(diff.x, highlightedElement.size.width));
              }
            }

            onEntryUpdate(highlightedElement.entryId, {
              posX: newPosition.x.toFixed(snapToGrid.decimals),
              posY: newPosition.y.toFixed(snapToGrid.decimals),
              width: Math.max(0, newSize.width).toFixed(snapToGrid.decimals),
              height: Math.max(0, newSize.height).toFixed(snapToGrid.decimals),
            });
          }
        };

        const handleMouseUp = (e) => {
          if (!highlightedElement || !highlightedElement.action) return;

          const mousePosition = getMousePosition(e, highlightedElement.ref);

          setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, action: null, position: null, size: null} : null);
        };

        const handleSnapToGrid = (value) => {
          const gridSize = parseFloat(value);
          const decimals = value.includes('.') ? value.split('.').pop().length : 0;
          setSnapToGrid({gridSize, decimals});
        };

        const roundToGrid = (value) => {
          return Math.round(value/snapToGrid.gridSize)*snapToGrid.gridSize;
        };

        return (
          <div id="visual-editor">
            <style>{revealCSS}</style>
            <h2>Visual Editor</h2>

            <div>
              <label><input type="checkbox" onChange={(e) => setRevealed(e.target.checked)} /> Reveal</label>
              <label>
                Snap to grid:
                <select value={snapToGrid.gridSize} onChange={(e) => handleSnapToGrid(e.target.value)}>
                  <option value="0.01">None</option>
                  <option value="0.1">Tiny</option>
                  <option value="1">Small</option>
                  <option value="5">Large</option>
                </select>
              </label>
            </div>
            
            <div
              className={`reveal-container ${revealed ? 'revealed' : ''} ${generateOptionsString(config)}`}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
            >
              <img className="reveal-background" src={config.backgroundImage} />
              {entries.slice().reverse().map((group, groupIndex) => (
              <React.Fragment key={groupIndex}>
                {group.slice().reverse().map((entry, entryIndex) => {
                  const id = `${entries.length - groupIndex - 1}-${group.length - entryIndex - 1}`;
                  const highlighted = (highlightedElement && highlightedElement.entryId === id) || entry.highlighted;
                  return (
                    <div
                      key={entryIndex}
                      className={`reveal ${entry.selected ? 'selected' : ''} ${highlighted ? 'highlighted' : ''} ${highlightedElement?.capability ? highlightedElement.capability : ''}`}
                      style={{ left: `${entry.posX}%`, top: `${entry.posY}%`, width: `${entry.width}%`, height: `${entry.height}%` }}
                      onMouseDown={(e) => handleMouseDown(e, id, entry, e.currentTarget.parentElement)}
                      onMouseEnter={(e) => handleMouseEnter(e, id, entry, e.currentTarget.parentElement)}
                      onMouseLeave={handleMouseLeave}
                    >
                      <input id={id} type="checkbox" />
                      <label htmlFor={id} dangerouslySetInnerHTML={{ __html: entry.label }} />
                      <div dangerouslySetInnerHTML={{ __html: entry.content }} />
                    </div>
                  );
                })}
                {groupIndex < entries.length - 1 && <div className="reveal-sequencing"></div>}
              </React.Fragment>
              ))}
            </div>
          </div>
        );
      }

      /**
       * HTML editor component
       */
      function HtmlEditor({ config, htmlContent }) {
        return (
          <div id="html-editor">
            <h2>ANKI Card - HTML Output</h2>

            <label>Options:</label>
            <input type="text" value={generateOptionsString(config)} style={{ width: '100%' }} disabled />
            
            <label>Back:</label>
            <textarea style={{ width: '100%', height: '200px' }} value={htmlContent} disabled></textarea>
          </div>
        )
      }

      function MyApp() {
        const defaultEntries = [];
        const initEntries = [
          [
            { selected: false, highlighted: false, label: "LABEL", content: "CONTENT", posX: "50", posY: "50", width: "20", height: "10" },
          ],
        ];

        const initBackgroundImage = "";
        const defaultConfig = {
          reversible: true,
          centered: true,
          hideable: false,
          backgroundImage: "",
          setReversible: (value) => setConfig((prevConfig) => ({ ...prevConfig, reversible: value })),
          setCentered: (value) => {
            const factor = value ? 1 : -1;
            const trailingZeros = /\.?0+$/;
            setConfig((prevConfig) => {
              setEntries((prevEntries) =>
                prevEntries.map((group) =>
                  group.map((entry) => {
                    const adjustments = Object.assign({},
                      ...Object.entries({posX: entry.width, posY: entry.height}).map(v => ({
                        [v[0]]: (parseFloat(entry[v[0]]) + factor * parseFloat(v[1])/2).toFixed(2).replace(trailingZeros, '')
                      }))
                    )
                    return { ...entry, ...adjustments };
                  })
                )
              );
              return { ...prevConfig, centered: value };
            });
          },
          setHideable: (value) => setConfig((prevConfig) => ({ ...prevConfig, hideable: value })),
          setBackgroundImage: (value) => setConfig((prevConfig) => ({ ...prevConfig, backgroundImage: value }))
        };

        const [entries, setEntries] = React.useState(initEntries);
        const [config, setConfig] = React.useState({...defaultConfig, backgroundImage: initBackgroundImage});

        const [htmlContent, setHtmlContent] = React.useState();

        React.useEffect(() => {
          const revealContainer = document.querySelector('#visual-editor .reveal-container');
          if (revealContainer) {
            setHtmlContent(revealContainer.innerHTML.replace(/(\<div\s+[^>]*class="([^"]*\s+)?reveal(-sequencing)?(\s+[^"]*)?"[^>]*>)/g, '\n\n$1'));
          }
        }, [entries, config]);

        const handleReset = () => {
          setEntries(defaultEntries);
          setConfig(defaultConfig);
        };

        const handleExport = () => {
          navigator.clipboard.writeText(htmlContent).then(() => {
            alert('Exported to clipboard!');
          }).catch(err => {
            console.error('Failed to copy: ', err);
          });
        };

        const handleEntryChange = (id, field, value) => {
          handleEntryUpdate(id, {[field]: value});
        };

        const handleEntryUpdate = (id, updatedFields) => {
          setEntries(prevEntries =>
            prevEntries.map((group, groupIndex) =>
              group.map((entry, entryIndex) => {
                const entryId = `${groupIndex}-${entryIndex}`;
                return entryId === id ? { ...entry, ...updatedFields } : entry;
              })
            )
          );
        };

        const handleAddEntry = () => {
          setEntries(prevEntries => {
            const newPosition = config.centered ? "50" : 45;
            const newEntry = { selected: true, highlighted: false, label: "", content: "", posX: newPosition, posY: newPosition, width: "10", height: "10" };

            if (prevEntries.length === 0) {
              return [[newEntry]];
            }

            return prevEntries.map((group, index) => 
              index === prevEntries.length - 1 ? [...group, newEntry] : group
            );
          });
        };

        const handleGroupEntries = () => {
          setEntries(prevEntries => {
            const result = [];
            let prevSelected = undefined;
            let prevGroupId = undefined;

            prevEntries.forEach((group, groupId) => {
              group.forEach(entry => {
                if (entry.selected !== prevSelected || (!entry.selected && groupId !== prevGroupId)) {
                  result.push([]);
                  prevSelected = entry.selected;
                  prevGroupId = groupId;
                }
                result[result.length - 1].push({...entry});
              });
            });

            return result;
          });
        };

        const handleIsolateEntries = () => {
          setEntries(prevEntries => {
            const result = [];
            let prevSelected = undefined;
            let prevGroupId = undefined;

            prevEntries.forEach((group, groupId) => {
              group.forEach(entry => {
                if (entry.selected || (!entry.selected && prevSelected) || groupId !== prevGroupId) {
                  result.push([]);
                  prevSelected = entry.selected;
                  prevGroupId = groupId;
                }
                result[result.length - 1].push({...entry});
              });
            });

            return result;
          });
        };

        const handleRemoveEntries = () => {
          setEntries(prevEntries =>
            prevEntries.map(group =>
              group.filter(entry => !entry.selected)
            ).filter(group => group.length > 0)
          );
        };

        const  handleMoveDown = () => {
          setEntries(prevEntries => {
            const result = [];
            let preventMoving = false;

            prevEntries.reverse().forEach((group, groupId) => {
              const newGroup = [];

              group.reverse().forEach(entry => {
                if (newGroup.length == 0) {
                  // First entry in the group
                  if (groupId == 0) {
                    // Last group, unable to move down, prevent further moving if selected
                    newGroup.push(entry);
                    preventMoving = entry.selected;
                  } else if(entry.selected && !preventMoving) {
                    // Overlap with previous group
                    result[0].unshift(entry);
                  } else {
                    newGroup.push(entry);
                  }
                } else if(entry.selected && !preventMoving) {
                  // Move entry inside the group
                  newGroup.splice(1, 0, entry);
                } else {
                  // Keep entry in the same position
                  newGroup.unshift(entry);
                }
              });
              result.unshift(newGroup);
            });

            return result.filter(group => group.length > 0);
          });
        };

        const  handleMoveUp = () => {
          setEntries(prevEntries => {
            const result = [];
            let preventMoving = false;

            prevEntries.forEach((group, groupId) => {
              const newGroup = [];

              group.forEach(entry => {
                if (newGroup.length == 0) {
                  // First entry in the group
                  if (groupId == 0) {
                    // First group, unable to move up, prevent further moving if selected
                    newGroup.push(entry);
                    preventMoving = entry.selected;
                  } else if(entry.selected && !preventMoving) {
                    // Overlap with previous group
                    result[result.length-1].push(entry);
                  } else {
                    newGroup.push(entry);
                  }
                } else if(entry.selected && !preventMoving) {
                  // Move entry inside the group
                  newGroup.splice(-1, 0, entry);
                } else {
                  // Keep entry in the same position
                  newGroup.push(entry);
                }
              });
              result.push(newGroup);
            });

            return result.filter(group => group.length > 0);
          });
        };

        return (
          <>
            <h1>Anki - Card-reveal Editor</h1>
            <Toolbar onReset={handleReset} onExport={handleExport} />
            <TableEditor entries={entries} onChange={handleEntryChange} onAddEntry={handleAddEntry} onGroupEntries={handleGroupEntries} onIsolateEntries={handleIsolateEntries} onMoveUp={handleMoveUp} onMoveDown={handleMoveDown} onRemoveEntries={handleRemoveEntries} />
            <Config config={config} />
            <VisualEditor entries={entries} config={config} htmlContent={htmlContent} onEntryUpdate={handleEntryUpdate} />
            <HtmlEditor config={config} htmlContent={htmlContent} />
          </>
        );
      }

      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<MyApp />);

    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      Read this page for starting a new React project with JSX:
      https://react.dev/learn/start-a-new-react-project

      Read this page for adding React with JSX to an existing project:
      https://react.dev/learn/add-react-to-an-existing-project
    -->
  </body>
</html>