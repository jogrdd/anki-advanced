<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Anki - Card-reveal Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom-server-legacy.browser.production.min.js"></script>

    <!-- Don't use this in production: -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <style>
      table {
        border-collapse: collapse;
      }
      tbody {
        border-bottom: 2px solid gray;
      }
      tbody:last-of-type {
        border-bottom: none;
      }
      .reveal-container {
        overflow: hidden;
      }
      /* Highlight styles */
      .reveal-container .reveal.selected {
        border: 5px solid rgba(0, 0, 255, 0.25);
        border-radius: 5px;
        z-index: 99;
      }
      .reveal-container .reveal.highlighted {
        border: 5px solid rgba(255, 0, 0, 0.25);
        border-radius: 5px;
        z-index: 100;
      }
      .reveal-container.drag * { cursor: move; }
      .reveal-container.resize-n, .reveal-container.resize-n *, .reveal-container.resize-s, .reveal-container.resize-s * { cursor: ns-resize; }
      .reveal-container.resize-e, .reveal-container.resize-e *, .reveal-container.resize-w, .reveal-container.resize-w * { cursor: ew-resize; }
      .reveal-container.resize-ne, .reveal-container.resize-ne *, .reveal-container.resize-sw, .reveal-container.resize-sw * { cursor: nesw-resize; }
      .reveal-container.resize-nw, .reveal-container.resize-nw *, .reveal-container.resize-se, .reveal-container.resize-se * { cursor: nwse-resize; }
      
      .reveal-container:not(.centered) .reveal.selected:not(.centered),
      .reveal-container.centered .reveal.selected.not-centered,
      .reveal-container:not(.centered) .reveal.highlighted:not(.centered),
      .reveal-container.centered .reveal.highlighted.not-centered {
          transform: translateX(-5px) translateY(-5px);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      /* React components */

      const EditMode = React.createContext(null);

      // Raw CSS used by advanced reveal features
      const revealCSS = `
        /****** REVEAL FUNCTIONALITY ******/
        /* USAGE

        - Add an image with class "reveal-background":

        <img class="reveal-background" src="{{Src}}">

        - For each reveal element, add the following HTML:

        <div class="reveal {{hint round border centered}}" style="top: {{Top}}; left: {{Left}}; height: {{Height}}; width: {{Width}};">
          <input id="{{ID}}" type="checkbox"></input>
          <label for="{{ID}}">{{Label}}</label>
          <div>{{Content}}</div>
        </div>

        - A generator is available at https://docs.google.com/spreadsheets/d/10xOEICIvBzzAa8FtoUb2MYhJlJLE-AfpuX9IoUlIQ0I/edit?usp=sharing

        - If not used in a reveal card type, manually add the following HTML around reveal items:

        <div class="reveal-container {{revealed centered reversible hideable front/back-gradient/transparent front/back-text-white/red}}">{...}</div>

        */

        .reveal-container {
            position: relative;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        .reveal-container .reveal-background {
            display: block;
            width: 100%;
            height: auto;
        }
        .reveal-container img.reveal-background {
            max-width: 100%;
        }

        .reveal-container > :not(.reveal-background):not(.reveal-sequencing):not(.reveal) {
            display: none;
        }

        .reveal-container .reveal {
            position: absolute;
            margin: 0;
            padding: 0;
            z-index: 1;
        }

        .reveal-container .reveal > input {
            margin-left:-99999px;
        }

        .reveal-container .reveal > input + label,
        .reveal-container .reveal > input + label + div
        {
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* NOT CHECKED */

        .reveal-container:not(.revealed) .reveal:not(.revealed) > input:not(:checked) + label + div,
        .reveal-container .reveal.revealed > input:checked + label + div,
        .reveal-container.revealed .reveal > input:checked + label + div
        {
            display: none;
        }

        /* CHECKED or REVEALED */

        .reveal-container:not(.revealed) .reveal:not(.revealed) > input:checked + label,
        .reveal-container .reveal.revealed > input:not(:checked) + label,
        .reveal-container.revealed .reveal > input:not(:checked) + label
        {
            opacity: 0;
        }

        .reveal-container:not(.revealed) .reveal:not(.revealed) .on-reveal {
          display: none;
        }

        /* DEFAULT LOOK */

        .reveal-container .reveal * {
            box-sizing: border-box;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
        }

        .reveal-container .reveal > input + label,
        .reveal-container .reveal > input + label + div {
            outline: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 2.5vw;
            background: white;
            border: none;
        }

        .reveal-container .reveal > input + label,
        .reveal-container .reveal > input + label + div,
        .reveal-container .reveal > input + label.text-black,
        .reveal-container .reveal.front-text-black > input + label,
        .reveal-container.front-text-black .reveal > input + label,
        .reveal-container .reveal > input + label + div.text-black,
        .reveal-container .reveal.back-text-black > input + label + div,
        .reveal-container.back-text-black .reveal > input + label + div
        {
            color: black;
            text-shadow: -1px -1px 1px white, 1px -1px 1px white, -1px 1px 1px white, 1px 1px 1px white;
        }

        /* ADDITIONAL LOOKS */
        .reveal-container .reveal > input + label.gradient,
        .reveal-container .reveal.front-gradient > input + label,
        .reveal-container.front-gradient .reveal > input + label,
        .reveal-container .reveal > input + label + div.gradient,
        .reveal-container .reveal.back-gradient > input + label + div,
        .reveal-container.back-gradient .reveal > input + label + div
        {
            background: radial-gradient(circle, white, transparent);
            border: none;
        }

        .reveal-container .reveal > input + label.transparent,
        .reveal-container .reveal.front-transparent > input + label,
        .reveal-container.front-transparent .reveal > input + label,
        .reveal-container .reveal > input + label + div.transparent,
        .reveal-container .reveal.back-transparent > input + label + div,
        .reveal-container.back-transparent .reveal > input + label + div
        {
            background: transparent;
            border: none;
        }

        .reveal-container .reveal > input + label.text-white,
        .reveal-container .reveal.front-text-white > input + label,
        .reveal-container.front-text-white .reveal > input + label,
        .reveal-container .reveal > input + label + div.text-white,
        .reveal-container .reveal.back-text-white > input + label + div,
        .reveal-container.back-text-white .reveal > input + label + div
        {
            color: white;
            text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
        }

        .reveal-container .reveal > input + label.text-red,
        .reveal-container .reveal.front-text-red > input + label,
        .reveal-container.front-text-red .reveal > input + label,
        .reveal-container .reveal > input + label + div.text-red,
        .reveal-container .reveal.back-text-red > input + label + div,
        .reveal-container.back-text-red .reveal > input + label + div
        {
            color: red;
            text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
        }

        /* CENTERED feature */

        .reveal-container .reveal.centered,
        .reveal-container.centered .reveal:not(.not-centered)
        {
            transform: translateX(-50%) translateY(-50%);
        }

        /* SEQUENCING feature */

        .reveal-container .reveal-sequencing {
          background: transparent;
          position: absolute;
          left: 0;
          top: 0;
          height: 100%;
          width: 100%;
          z-index: 1;
          display: none;
        }

        .reveal-container:not(.revealed) .reveal-sequencing:has(~ .reveal:not(.revealed) > input:not(:checked) + label)
        {
          display: block;
        }

        /* REVERSIBLE feature */

        .reveal-container .reveal > input:checked + label.reversible,
        .reveal-container .reveal.reversible > input:checked + label,
        .reveal-container.reversible .reveal > input:checked + label,
        .reveal-container .reveal.revealed > input:not(:checked)+ label.reversible,
        .reveal-container .reveal.revealed.reversible > input:not(:checked) + label,
        .reveal-container.reversible .reveal.revealed > input:not(:checked) + label,
        .reveal-container.revealed .reveal > input:not(:checked)+ label.reversible,
        .reveal-container.revealed .reveal.reversible > input:not(:checked) + label,
        .reveal-container.revealed.reversible .reveal > input:not(:checked) + label
        {
            z-index: 2;
        }

        /* HIDEABLE feature */

        .reveal-container .reveal.revealed > input:not(:checked)+ label.hideable,
        .reveal-container .reveal.revealed.hideable > input:not(:checked) + label,
        .reveal-container.hideable .reveal.revealed > input:not(:checked) + label,
        .reveal-container.revealed .reveal > input:not(:checked)+ label.hideable,
        .reveal-container.revealed .reveal.hideable > input:not(:checked) + label,
        .reveal-container.revealed.hideable .reveal > input:not(:checked) + label
        {
            z-index: 2;
        }

        .reveal-container .reveal.revealed > input:checked + label.hideable,
        .reveal-container.revealed .reveal > input:checked + label.hideable,
        .reveal-container .reveal.revealed.hideable > input:checked + label,
        .reveal-container.revealed .reveal.hideable > input:checked + label,
        .reveal-container.hideable .reveal.revealed > input:checked + label,
        .reveal-container.revealed.hideable .reveal > input:checked + label
        {
            opacity: 0;
        }
      `;

      /**
       * Toolbar component
       */
      function Toolbar({ onReset, onExport, history, onUndo, onRedo }) {
        const editMode = React.useContext(EditMode);

        return (
          <div>
            <button onClick={onReset}>Reset</button>
            <button onClick={onExport}>Copy to Clipboard</button>
            <button onClick={onUndo} disabled={editMode != 'visual' || !history.undo}>Undo</button>
            <button onClick={onRedo} disabled={editMode != 'visual' || !history.redo}>Redo</button>
          </div>
        );
      }

      /**
       * Table editor entry component
       */
      function TableEditorEntry({ id, selected, highlighted, label, content, posX, posY, width, height, options, onChange, onHighlight, onSaveHistory }) {
        const editing = React.useRef(false);
        const editMode = React.useContext(EditMode);

        const handleInputFocus = (e) => {
          editing.current = false;
        };
        
        const inputChangeHandler = (field) => {
          return (e) => {
            if (!editing.current) {
              editing.current = true;
              onSaveHistory();
            }
            onChange(id, field, e.target.value);
          }
        };

        return (
          <tr onMouseEnter={() => onHighlight(true)} onMouseLeave={() => onHighlight(false)}>
            <td><input type="checkbox" checked={selected} onChange={(e) => onChange(id, 'selected', e.target.checked)} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={label} onChange={inputChangeHandler('label')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={content} onChange={inputChangeHandler('content')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={posX} onChange={inputChangeHandler('posX')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={posY} onChange={inputChangeHandler('posY')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={width} onChange={inputChangeHandler('width')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={height} onChange={inputChangeHandler('height')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
            <td><input type="text" value={options} onChange={inputChangeHandler('options')} onFocus={handleInputFocus} disabled={editMode != 'visual'} /></td>
          </tr>
        );
      }

      /**
       * Config component
       */
      function Config({ config, onChange, onSaveHistory }) {
        const editMode = React.useContext(EditMode);

        const handleFileUpload = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
              onSaveHistory();
              onChange('backgroundImage', reader.result);
            };
            reader.readAsDataURL(file);
          }
        };

        const getCheckboxHandler = (action) => {
          return (e) => { onSaveHistory(); onChange(action, e.target.checked) };
        }

        return (
          <div>
            <h2>Config</h2>
            <div>
              <label>
                Background Image:
                <input type="file" accept="image/*" onChange={handleFileUpload} disabled={editMode != 'visual'} />
              </label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.reversible} onChange={getCheckboxHandler('reversible') } disabled={editMode != 'visual'} /> Reversible</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.centered} onChange={getCheckboxHandler('centered') } disabled={editMode != 'visual'} /> Centered</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.hideable} onChange={getCheckboxHandler('hideable') } disabled={editMode != 'visual'} /> Hideable</label> - <span>once revealed, content can be hidden</span>
            </div>
          </div>
        );
      }

      /**
       * Table editor component
       */
      function TableEditor({ entries, onChange, onChangeSelected, onSaveHistory }) {
        const [selectAllChecked, setSelectAllChecked] = React.useState(false);
        const [selectAllIndeterminate, setSelectAllIndeterminate] = React.useState(false);
        const [selectedCount, setSelectedCount] = React.useState(false);

        const editMode = React.useContext(EditMode);

        const handleSelectAll = (e) => {
          const checked = e.target.checked;
          setSelectAllChecked(checked);
          setSelectAllIndeterminate(false);
          entries.forEach((group, groupIndex) => {
            group.forEach((entry, entryIndex) => {
              onChange('update', `${groupIndex}-${entryIndex}`, { selected: checked });
            });
          });
        };

        const handleHighlight = (id, value) => onChange('update', id, { highlighted: value });

        React.useEffect(() => {
          const totalEntries = entries.flat().length;
          const count = entries.flat().filter(entry => entry.selected).length;
          setSelectedCount(count);

          if (count === 0) {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(false);
          } else if (count === totalEntries) {
            setSelectAllChecked(true);
            setSelectAllIndeterminate(false);
          } else {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(true);
          }
        }, [entries]);

        const entryHandler = (action) => {
          return () => { onSaveHistory(); onChange(action); };
        }

        const selectedEntriesHandler = (action, ...args) => {
          return () => { onSaveHistory(); onChangeSelected(action, ...args); };
        }

        return (
          <div>
            <h2>Entries</h2>
            <table>
              <thead>
                <tr>
                  <th>
                    <input
                      type="checkbox"
                      checked={selectAllChecked}
                      ref={el => el && (el.indeterminate = selectAllIndeterminate)}
                      onChange={handleSelectAll}
                      disabled={editMode != 'visual'}
                    />
                  </th>
                  <th>Label</th>
                  <th>Content</th>
                  <th>PosX (%)</th>
                  <th>PosY (%)</th>
                  <th>Width (%)</th>
                  <th>Height (%)</th>
                  <th>Options</th>
                </tr>
              </thead>
              {entries.map((entry, groupIndex) => (
                <tbody key={groupIndex}>
                  {entry.map((entry, index) => (
                    <TableEditorEntry
                      key={index}
                      id={`${groupIndex}-${index}`}
                      {...entry}
                      onChange={(id, field, value) => onChange('update', id, { [field]: value })}
                      onHighlight={(value) => handleHighlight(`${groupIndex}-${index}`, value)}
                      onSaveHistory={onSaveHistory}
                    />
                  ))}
                </tbody>
              ))}
              <tfoot>
                <tr>
                  <td colSpan="8">
                    <span>{selectedCount} rows selected - </span>
                    <button onClick={selectedEntriesHandler('group')} disabled={editMode != 'visual' || !selectedCount}>Group</button>
                    <button onClick={selectedEntriesHandler('isolate')} disabled={editMode != 'visual' || !selectedCount}>Isolate</button>

                    <button onClick={selectedEntriesHandler('move', 'up')} disabled={editMode != 'visual' || !selectedCount}>Move Up</button>
                    <button onClick={selectedEntriesHandler('move', 'down')} disabled={editMode != 'visual' || !selectedCount}>Move Down</button>

                    <button onClick={selectedEntriesHandler('delete')} disabled={editMode != 'visual' || !selectedCount}>Remove</button>

                    <button onClick={entryHandler('create')} disabled={editMode != 'visual'}>Add</button>
                  </td>
                </tr>
              </tfoot>
            </table>
          </div>
        );
      }

      /**
       * Generate options string from config
       */
      const filterConfigOptions = (config) => ['reversible', 'centered', 'hideable'].filter(option => config[option]);

      /**
       * Visual editor component
       */
      function VisualEditor({ entries, config, htmlContent, onEntryChange, onSaveHistory }) {
        const [revealed, setRevealed] = React.useState(false);
        const [highlightedElement, setHighlightedElement] = React.useState(null);
        const [snapToGrid, setSnapToGrid] = React.useState({gridSize: 1, decimals: 0});

        const editMode = React.useContext(EditMode);

        const clamp = (x, min, max) => Math.max(0, Math.min(100, x));

        const getMousePosition = (e, ref) => {
          const rect = ref.getBoundingClientRect();
          const distances = {
            left: e.clientX - rect.left - e.target.clientLeft,
            right: rect.left - e.target.clientLeft + rect.width - e.clientX,
            top: e.clientY - rect.top - e.target.clientTop,
            bottom: rect.top - e.target.clientTop + rect.height - e.clientY,
          };
          return {
            e,
            ref,
            x: clamp(distances.left/rect.width*100, 0, 100),
            y: clamp(distances.top/rect.height*100, 0, 100),
            ...distances,
          };
        };

        const getElementCapability = (e, target) => {
          const mouseElementPosition = getMousePosition(e, target);
          
          const border = Object.entries({
            n: mouseElementPosition.top <= 5,
            s: mouseElementPosition.bottom <= 5,
            e: mouseElementPosition.right <= 5,
            w: mouseElementPosition.left <= 5,
          }).filter(b => b[1]).map(b => b[0]).join('');

          return border.length ? 'resize-' + border : 'drag';
        };

        const handleMouseEnter = (e, entryId, entry, ref) => {
          const newHighlightedElement = { entryId, entry, target: e.target, ref, position: null, size: null, capability: null };
          setHighlightedElement(prevHighlightedElement => prevHighlightedElement?.action ? prevHighlightedElement : newHighlightedElement); // Handle previous helement here
        };

        const handleMouseLeave = () => {
          setHighlightedElement(prevHighlightedElement => prevHighlightedElement?.action ? prevHighlightedElement : null);
        };

        const handleMouseDown = (e, entryId, entry, ref) => {
          if (!highlightedElement) return;
          
          onSaveHistory();

          const position = { x: parseFloat(entry.posX), y: parseFloat(entry.posY) };
          const size = { width: parseFloat(entry.width), height: parseFloat(entry.height) };
          const capability = highlightedElement.capability;
          
          if (capability == 'drag' && !highlightedElement.action) {
            const newAction = { action: 'drag', position, size, mousePosition: getMousePosition(e, ref) };
            setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, ...newAction} : null); // TODO: No need for entryId and entry...
          }

          if (capability.startsWith('resize-')) {
            const newAction = { action: 'resize', position, size, direction: capability.split('-').pop(), mousePosition: getMousePosition(e, ref) };
            setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, ...newAction} : null); // TODO: No need for entryId and entry...
          }
        };

        const handleMouseMove = (e) => {
          if (!highlightedElement) return;

          if (!highlightedElement.action) {
            // Update capability if not during an action
            const capability = getElementCapability(e, highlightedElement.target);
            setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, capability} : null);
          }
          
          if (highlightedElement.action === 'drag') {
            const mousePosition = getMousePosition(e, highlightedElement.ref);
            const diff = { x: mousePosition.x - highlightedElement.mousePosition.x, y: mousePosition.y - highlightedElement.mousePosition.y };
            const newPosition = {
              x: roundToGrid(highlightedElement.position.x + diff.x),
              y: roundToGrid(highlightedElement.position.y + diff.y),
            };

            onEntryChange('update', highlightedElement.entryId, { posX: newPosition.x.toFixed(snapToGrid.decimals), posY: newPosition.y.toFixed(snapToGrid.decimals) });
          }

          if (highlightedElement.action === 'resize') {
            const mousePosition = getMousePosition(e, highlightedElement.ref);
            const diff = { x: mousePosition.x - highlightedElement.mousePosition.x, y: mousePosition.y - highlightedElement.mousePosition.y };
            const newPosition = {...highlightedElement.position};
            const newSize = {...highlightedElement.size};
            const resizeMultiplier = config.centered ? 2 : 1;
            const direction = highlightedElement.direction;

            if (direction.includes('n')) {
              newSize.height = roundToGrid(highlightedElement.size.height - diff.y * resizeMultiplier); // Improve roundToGrid
              if (!config.centered) {
                newPosition.y = roundToGrid(highlightedElement.position.y + Math.min(diff.y, highlightedElement.size.height));
              }
            }
            if (direction.includes('s')) {
              newSize.height = roundToGrid(highlightedElement.size.height + diff.y * resizeMultiplier); // Improve roundToGrid
            }
            if (direction.includes('e')) {
              newSize.width = roundToGrid(highlightedElement.size.width + diff.x * resizeMultiplier); // TODO: Improve roundToGrid
            }
            if (direction.includes('w')) {
              newSize.width = roundToGrid(highlightedElement.size.width - diff.x * resizeMultiplier); // TODO: Improve roundToGrid
              if (!config.centered) {
                newPosition.x = roundToGrid(highlightedElement.position.x + Math.min(diff.x, highlightedElement.size.width));
              }
            }

            onEntryChange('update', highlightedElement.entryId, {
              posX: newPosition.x.toFixed(snapToGrid.decimals),
              posY: newPosition.y.toFixed(snapToGrid.decimals),
              width: Math.max(0, newSize.width).toFixed(snapToGrid.decimals),
              height: Math.max(0, newSize.height).toFixed(snapToGrid.decimals),
            });
          }
        };

        const handleMouseUp = (e) => {
          if (!highlightedElement || !highlightedElement.action) return;

          setHighlightedElement(prevHighlightedElement => prevHighlightedElement ? {...prevHighlightedElement, action: null, position: null, size: null} : null);
        };

        const handleSnapToGrid = (value) => {
          const gridSize = parseFloat(value);
          const decimals = value.includes('.') ? value.split('.').pop().length : 0;
          setSnapToGrid({gridSize, decimals});
        };

        const roundToGrid = (value) => {
          return Math.round(value/snapToGrid.gridSize)*snapToGrid.gridSize;
        };

        return (
          <div id="visual-editor">
            <h2>Visual Editor</h2>

            <div>
              <label><input type="checkbox" checked={revealed} onChange={(e) => setRevealed(e.target.checked)} /> Reveal</label>
              <label>
                Snap to grid:
                <select value={snapToGrid.gridSize} onChange={(e) => handleSnapToGrid(e.target.value)} disabled={editMode != 'visual'}>
                  <option value="0.01">None</option>
                  <option value="0.1">Tiny</option>
                  <option value="1">Small</option>
                  <option value="5">Large</option>
                </select>
              </label>
            </div>

            <div>
              <style>{revealCSS}</style>

              { editMode == 'visual' && (
                <div
                  className={[
                    'reveal-container',
                    revealed ? 'revealed' : null,
                    ...filterConfigOptions(config),
                    highlightedElement?.capability ? highlightedElement.capability : null,
                  ].filter(c => c).join(' ')}
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                >
                  <img className="reveal-background" src={config.backgroundImage} />
                  {entries.slice().reverse().map((group, groupIndex) => (
                    <React.Fragment key={groupIndex}>
                      {group.slice().reverse().map((entry, entryIndex) => {
                        const id = `${entries.length - groupIndex - 1}-${group.length - entryIndex - 1}`;
                        const highlighted = (highlightedElement && highlightedElement.entryId === id) || entry.highlighted;
                        return (
                          <div
                            key={entryIndex}
                            className={[
                              'reveal',
                              entry.selected ? 'selected' : null,
                              highlighted ? 'highlighted' : null,
                              ...entry.options.split(' '),
                            ].filter(c => c).join(' ')}
                            style={{ left: entry.posX+'%', top: entry.posY+'%', width: entry.width+'%', height: entry.height+'%' }}
                            onMouseDown={(e) => handleMouseDown(e, id, entry, e.currentTarget.parentElement)}
                            onMouseEnter={(e) => handleMouseEnter(e, id, entry, e.currentTarget.parentElement)}
                            onMouseLeave={handleMouseLeave}
                          >
                            <input id={id} type="checkbox" />
                            <label htmlFor={id} dangerouslySetInnerHTML={{ __html: entry.label }} />
                            <div dangerouslySetInnerHTML={{ __html: entry.content }} />
                          </div>
                        );
                      })}
                      {groupIndex < entries.length - 1 && <div className="reveal-sequencing"></div>}
                    </React.Fragment>
                  ))}
                </div>
              )}

              { editMode == 'html' && (
                <div>
                  <div className="header">Deck</div>

                  <div className="frame">
                      <div className="front">Front/Title</div>
                      <div className="back">
                        <Preview entries={entries} config={config} reveal={revealed} />
                      </div>
                      <div className="mnemonic">Mnemonic...</div>
                  </div>

                  <div className="source">
                    <div className="default"><a href="https://fr.wikipedia.org">Source link</a></div>
                    Other source...
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      /**
       * Preview component
       */
      function Preview({ entries, config, reveal }) {
        return (
          <div className={[ 'reveal-container', reveal ? 'revealed' : null, ...filterConfigOptions(config), ].filter(c => c).join(' ')}>
            <img className="reveal-background" src={config.backgroundImage} />
            {entries.slice().reverse().map((group, groupIndex) => (
              <React.Fragment key={groupIndex}>
                {group.slice().reverse().map((entry, entryIndex) => {
                  const id = `${entries.length - groupIndex - 1}-${group.length - entryIndex - 1}`;
                  return (
                    <div
                      key={entryIndex}
                      className={['reveal', ...entry.options.split(' ')].filter(c => c).join(' ')}
                      style={{ left: entry.posX+'%', top: entry.posY+'%', width: entry.width+'%', height: entry.height+'%' }}
                    >
                      <input id={id} type="checkbox" />
                      <label htmlFor={id} dangerouslySetInnerHTML={{ __html: entry.label }} />
                      <div dangerouslySetInnerHTML={{ __html: entry.content }} />
                    </div>
                  );
                })}
                {groupIndex < entries.length - 1 && <div className="reveal-sequencing"></div>}
              </React.Fragment>
            ))}
          </div>
        );
      }

      /**
       * HTML editor component
       */
      function HtmlEditor({ htmlContent, onHtmlContentChange, importStatus, onEditMode }) {
        const editMode = React.useContext(EditMode);

        return (
          <div id="html-editor">
            <h2>HTML Editor</h2>
            
            <textarea style={{ width: '100%', height: '200px' }} value={htmlContent} onChange={(e) => onHtmlContentChange(e.target.value)} disabled={editMode != 'html'}></textarea>
            
            { editMode == 'html' && (
              <>
                <button onClick={() => onEditMode('visual', true)} disabled={!importStatus.valid}>Save</button>
                <button onClick={() => onEditMode('visual', false)}>Cancel</button>

                <span>{importStatus.errors.join(" - ")}</span>
                <span>{importStatus.warnings.join(" - ")}</span>
              </>
            ) || (
              <button onClick={() => onEditMode('html')}>Edit...</button>
            ) }
          </div>
        )
      }

      function MyApp() {
        const defaultEntries = [];
        const initEntries = [
          [
            { selected: false, highlighted: false, label: "LABEL", content: "CONTENT", posX: "50", posY: "50", width: "20", height: "10" },
          ],
        ];

        const initBackgroundImage = "";
        const defaultConfig = {
          reversible: true,
          centered: true,
          hideable: false,
          backgroundImage: "",
        };
        const initHistory = (entries, config) => ({values: [], index: 0, undo: false, redo: false});

        /**
         * Adjusts the coordinate origin of all entries between center and top-left, depending on the value of the reverse argument.
         * Parameters:
         *   - entries: An array of entry objects whose coordinates need to be adjusted.
         *   - reverse: A boolean indicating the direction of adjustment. 
         *        If true, changes the origin from center to top-left. 
         *        If false, changes the origin from top-left to center.
         */
        const centerEntries = (entries, reverse) => {
          const factor = reverse ? -1 : 1;
          const trailingZeros = /\.?0+$/;
          return entries.map(group =>
              group.map((entry) => {
                const adjustments = Object.assign({},
                  ...Object.entries({posX: entry.width, posY: entry.height}).map(v => ({
                    [v[0]]: (parseFloat(entry[v[0]]) + factor * parseFloat(v[1])/2).toFixed(2).replace(trailingZeros, '')
                  }))
                )
                return { ...entry, ...adjustments };
              })
            );
        };

        const stateReducer = (state, action) => {
          switch (action.type) {
            case 'reset': {
              return { ...state, entries: defaultEntries, config: defaultConfig, history: initHistory(defaultEntries, defaultConfig) };
            }

            case 'import': {
              const entries = action.entries;
              const config = { ...defaultConfig, ...action.config };
              return { ...state, entries, config };
            }

            case 'changeConfig': {
              const entries = (action.key === 'centered' ? centerEntries(state.entries, !action.value) : state.entries );
              const config = { ...state.config, [action.key]: action.value };
              return { ...state, entries, config };
            }

            case 'updateEntry': {
              const entries = state.entries.map((group, groupIndex) =>
                group.map((entry, entryIndex) => {
                  const entryId = `${groupIndex}-${entryIndex}`;
                  return entryId === action.id ? { ...entry, ...action.fields } : entry;
                })
              );
              return { ...state, entries };
            }

            case 'createEntry': {
              const newPosition = state.config.centered ? "50" : 45;
              const newEntry = { selected: true, highlighted: false, label: "", content: "", posX: newPosition, posY: newPosition, width: "10", height: "10", options: "" };

              if (state.entries.length === 0) {
                return { ...state, entries: [[newEntry]] };
              }

              return {
                ...state,
                entries: state.entries.map((group, index) => index === state.entries.length - 1 ? [...group, newEntry] : group),
              };
            }

            case 'deleteSelectedEntries': {
              const entries = state.entries.map(group =>
                group.filter(entry => !entry.selected)
              ).filter(group => group.length > 0);

              return { ...state, entries };
            }

            case 'groupSelectedEntries':
            case 'isolateSelectedEntries': {
              const entries = [];
              let prevSelected = undefined;
              let prevGroupId = undefined;

              state.entries.forEach((group, groupId) => {
                group.forEach(entry => {
                  const groupCondition = (action.type === 'groupSelectedEntries') && (entry.selected !== prevSelected || (!entry.selected && groupId !== prevGroupId));
                  const isolateCondition = (action.type === 'isolateSelectedEntries') && (entry.selected || (!entry.selected && prevSelected) || groupId !== prevGroupId);
                  if (groupCondition || isolateCondition) {
                    entries.push([]);
                    prevSelected = entry.selected;
                    prevGroupId = groupId;
                  }
                  entries[entries.length - 1].push({...entry});
                });
              });

              return { ...state, entries };
            }

            case 'moveSelectedEntries': {
              const dirUp = (action.direction === 'up');
              const entries = [];
              let preventMoving = false;

              (dirUp ? state.entries : [...state.entries].reverse()).forEach((group, groupId) => {
                const newGroup = [];

                (dirUp ? group : [...group].reverse()).forEach(entry => {
                  if (newGroup.length == 0) {
                    // First entry in the group
                    if (groupId == 0) {
                      // Last group, unable to move down, prevent further moving if selected
                      newGroup.push(entry);
                      preventMoving = entry.selected;
                    } else if(entry.selected && !preventMoving) {
                      // Overlap with previous group
                      if (dirUp) entries[entries.length-1].push(entry); else entries[0].unshift(entry);
                    } else {
                      newGroup.push(entry);
                    }
                  } else if(entry.selected && !preventMoving) {
                    // Move entry inside the group
                    newGroup.splice(dirUp ? -1 : 1, 0, entry);
                  } else {
                    // Keep entry in the same position
                    if (dirUp) newGroup.push(entry); else newGroup.unshift(entry);
                  }
                });

                if (dirUp) entries.push(newGroup); else entries.unshift(newGroup);
              });

              return { ...state, entries: entries.filter(group => group.length > 0) };
            }

            case 'saveHistory': {
              const length = state.history.values.length;
              const index = state.history.index;
              const values = state.history.values.slice(0, index);
              values.push({ entries: state.entries, config: state.config });

              return {
                ...state,
                history: {
                  values,
                  index: index + 1,
                  undo: true,
                  redo: false,
                }
              };
            }

            case 'undo': {
              const prevIndex = state.history.index - 1;
              if (prevIndex < 0) return {...state};

              const values = state.history.values;
              if (values.length <= state.history.index) {
                values.push({ entries: state.entries, config: state.config });
              }

              return {
                ...state,
                entries: state.history.values[prevIndex].entries,
                config: state.history.values[prevIndex].config,
                history: { ...state.history, index: prevIndex, undo: prevIndex > 0, redo: true },
              };
            };

            case 'redo': {
              const nextIndex = state.history.index + 1;
              const lastIndex = state.history.values.length - 1;
              if (nextIndex > lastIndex) return {...state};

              return {
                ...state,
                entries: state.history.values[nextIndex].entries,
                config: state.history.values[nextIndex].config,
                history: { ...state.history, index: nextIndex, undo: true, redo: nextIndex < lastIndex },
              };
            };

            default:
              return state;
          }
        };

        const [state, dispatch] = React.useReducer(stateReducer, {
          entries: initEntries,
          config: defaultConfig,
          backgroundImage: initBackgroundImage,
        }, (init) => {
          const entries = init.entries;
          const config = {...init.config, backgroundImage: init.backgroundImage};

          return {
            entries,
            config,
            history: initHistory(entries, config),
          }
        });

        const [htmlContent, setHtmlContent] = React.useState();
        const editingHtmlContent = React.useRef(false);
        const [editMode, setEditMode] = React.useState('visual');
        const [importStatus, setImportStatus] = React.useState({ errors: [], warnings: [], valid: false });

        React.useEffect(() => {
          if (editMode != 'visual') return;

          const html = ReactDOMServer.renderToString(<Preview entries={state.entries} config={state.config} reveal={false} />);
          setHtmlContent(html.replace(/(\<\w+\s+[^>]*class="([^"]*\s+)?(reveal|reveal-background|reveal-sequencing)(\s+[^"]*)?"[^>]*>)/g, '\n$1'));
        }, [state, editMode]);

        const handleReset = () => {
          dispatch({ type: 'reset' });
        };

        const handleExport = () => {
            const toaster = document.createElement('div');
            toaster.style.position = 'fixed';
            toaster.style.bottom = '5%';
            toaster.style.left = '5%';
            toaster.style.right = '5%';
            toaster.style.padding = '2%';
            toaster.style.backgroundColor = '#333';
            toaster.style.color = '#fff';
            toaster.style.borderRadius = '10px';
            toaster.style.zIndex = '1000';

            navigator.clipboard.writeText(htmlContent).then(() => {
              toaster.textContent = '✅ Copied to clipboard!';
              document.body.appendChild(toaster);
              setTimeout(() => document.body.removeChild(toaster), 3000);
            }).catch(err => {
              toaster.textContent = '⚠️ Failed to copy!';
              document.body.appendChild(toaster);
              setTimeout(() => document.body.removeChild(toaster), 10000);
            });
        };

        const handleConfigChange = (key, value) => {
          dispatch({ type: 'changeConfig', key, value });
        };

        const handleEntryChange = (action, id, fields) => {
          if (action === 'create') dispatch({ type: 'createEntry', id, fields });
          if (action === 'update') dispatch({ type: 'updateEntry', id, fields });
          if (action === 'delete') dispatch({ type: 'delete', id });
        };

        const handleSelectedEntriesChange = (action, ...args) => {
          if (action === 'delete') dispatch({ type: 'deleteSelectedEntries' });
          if (action === 'group') dispatch({ type: 'groupSelectedEntries' });
          if (action === 'isolate') dispatch({ type: 'isolateSelectedEntries' });
          if (action === 'move') dispatch({ type: 'moveSelectedEntries', direction: args[0] });
        };

        const historyHandler = {
          save: () => dispatch({ type: 'saveHistory' }),
          undo: () => dispatch({ type: 'undo' }),
          redo: () => dispatch({ type: 'redo' }),
        };

        /**
         * App shortcuts
         */
        React.useEffect(() => {
          const handleKeyDown = (e) => {
            const activeElement = document.activeElement;
            const isFormElement = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA';

            if (!isFormElement) {
              if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                dispatch({ type: 'undo' });
              }
              if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                dispatch({ type: 'redo' });
              }
            }
          };

          document.addEventListener('keydown', handleKeyDown);
          return () => {
            document.removeEventListener('keydown', handleKeyDown);
          };
        }, []);

        const importPercentValue = (value) => {
            const match = value.match(/^(\d+(\.\d+)?)%$/);
            return match ? parseFloat(match[1]) : null;
        }

        const handleHtmlContent = (html) => {
          if (editMode != 'html') return;

          if (!editingHtmlContent.current) {
            dispatch({ type: 'saveHistory' });
            editingHtmlContent.current = true;
          }

          setHtmlContent(html);

          // Parse HTMl
          const entries = [];
          const config = {backgroundImage: ''};
          const errors = [];
          const warnings = [];
          
          const parser = new DOMParser();
          const document = parser.parseFromString(html, 'text/html');

          const firstElement = document.body.firstElementChild;
          if (!firstElement.classList.contains('reveal-container')) {
            errors.push('Missing or invalid class "reveal-container" on the first element.');
          } else {
            const options = Array.from(firstElement.classList).filter(cls => cls !== 'reveal-container');

            Object.keys(defaultConfig).forEach(key => {
              if (key === 'backgroundImage') return;
              config[key] = options.includes(key);
            });

            options.forEach(option => {
              if (!(option in defaultConfig)) {
                config[option] = true;
                warnings.push(`Unknown option "${option}"`);
              }
            });
          }
          
          const backgroundElements = document.querySelectorAll('.reveal-background');
          if (backgroundElements.length == 0) {
            errors.push('Missing element reveal-background');
          } else {
            config.backgroundImage = backgroundElements[0].src;
          }
          if (backgroundElements.length > 1) {
            warnings.push('Too many "reveal-background" elements found, subsequent ones will be discarder');
          }

          const revealElements = document.querySelectorAll('.reveal, .reveal-sequencing');
          let currentGroup = [];
          revealElements.forEach((element) => {
            if (element.classList.contains('reveal-sequencing')) {
              if (currentGroup.length > 0) {
                entries.unshift(currentGroup);
                currentGroup = [];
              }
            } else if (element.classList.contains('reveal')) {
              const entry = {
                selected: false,
                highlighted: false,
                label: element.querySelector('label')?.innerHTML || '',
                content: element.querySelector('div')?.innerHTML || '',
                posX: (() => {
                  const value = importPercentValue(element.style.left);
                  if (value === null) errors.push('Invalid format for posX: ' + element.style.left);
                  return value || 0;
                })(),
                posY: (() => {
                  const value = importPercentValue(element.style.top);
                  if (value === null) errors.push('Invalid format for posY: ' + element.style.top);
                  return value || 0;
                })(),
                width: (() => {
                  const value = importPercentValue(element.style.width);
                  if (value === null) errors.push('Invalid format for width: ' + element.style.width);
                  return value || 0;
                })(),
                height: (() => {
                  const value = importPercentValue(element.style.height);
                  if (value === null) errors.push('Invalid format for height: ' + element.style.height);
                  return value || 0;
                })(),
                options: Array.from(element.classList).filter(cls => cls !== 'reveal').join(' '),
              };

              currentGroup.unshift(entry);
            }
          });

          if (currentGroup.length > 0) {
            entries.unshift(currentGroup);
          }

          dispatch({ type: 'import', entries, config});
          setImportStatus({ errors, warnings, valid: errors.length === 0 });
        };

        const handleEditMode = (mode, acceptImport) => {
          editingHtmlContent.current = false;

          if (mode === 'html') {
            setEditMode('html');
            return;
          }

          if (mode === 'visual') {
            if (!acceptImport) {
              dispatch({ type: 'undo' });
            }
            setEditMode('visual');
            return;
          }
        };

        return (
          <>
            <h1>Anki - Card-reveal Editor</h1>
            <EditMode.Provider value={editMode}>
              <Toolbar onReset={handleReset} onExport={handleExport} editMode={editMode} history={state.history} onUndo={historyHandler.undo} onRedo={historyHandler.redo} />
              <TableEditor entries={state.entries} onChange={handleEntryChange} onChangeSelected={handleSelectedEntriesChange} editMode={editMode} onSaveHistory={historyHandler.save} />
              <Config config={state.config} onChange={handleConfigChange} editMode={editMode} onSaveHistory={historyHandler.save} />
              <VisualEditor entries={state.entries} config={state.config} htmlContent={htmlContent} editMode={editMode} onEntryChange={handleEntryChange} onSaveHistory={historyHandler.save} />
              <HtmlEditor htmlContent={htmlContent} importStatus={importStatus} onEditMode={handleEditMode} onHtmlContentChange={handleHtmlContent} />
            </EditMode.Provider>
          </>
        );
      }

      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<MyApp />);

    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      Read this page for starting a new React project with JSX:
      https://react.dev/learn/start-a-new-react-project

      Read this page for adding React with JSX to an existing project:
      https://react.dev/learn/add-react-to-an-existing-project
    -->
  </body>
</html>