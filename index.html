<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Anki - Card-reveal Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Don't use this in production: -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <style>
      table {
        border-collapse: collapse;
      }
      tbody {
        border-bottom: 2px solid gray;
      }
      tbody:last-of-type {
        border-bottom: none;
      }
      /* Highlight styles */
      .reveal.highlight {
        border: 2px solid blue;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      /* React components */

      /**
       * Toolbar component
       */
      function Toolbar({ onReset, onExport }) {
        return (
          <div>
            <button onClick={onReset}>Reset</button>
            <button onClick={onExport}>Export to Clipboard</button>
          </div>
        );
      }

      /**
       * Table editor entry component
       */
      function TableEditorEntry({ id, selected, highlighted, label, content, posX, posY, width, height, onChange, onHighlight }) {
        return (
          <tr onMouseEnter={() => onHighlight(true)} onMouseLeave={() => onHighlight(false)}>
            <td><input type="checkbox" checked={selected} onChange={(e) => onChange(id, 'selected', e.target.checked)} /></td>
            <td><input type="text" value={label} onChange={(e) => onChange(id, 'label', e.target.value)} /></td>
            <td><input type="text" value={content} onChange={(e) => onChange(id, 'content', e.target.value)} /></td>
            <td><input type="text" value={posX} onChange={(e) => onChange(id, 'posX', e.target.value)} /></td>
            <td><input type="text" value={posY} onChange={(e) => onChange(id, 'posY', e.target.value)} /></td>
            <td><input type="text" value={width} onChange={(e) => onChange(id, 'width', e.target.value)} /></td>
            <td><input type="text" value={height} onChange={(e) => onChange(id, 'height', e.target.value)} /></td>
          </tr>
        );
      }

      /**
       * Config component
       */
      function Config({ config }) {
        const handleFileUpload = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
              config.setBackgroundImage(reader.result);
            };
            reader.readAsDataURL(file);
          }
        };

        return (
          <div>
            <h2>Config</h2>
            <div>
              <label>
                Background Image:
                <input type="file" accept="image/*" onChange={handleFileUpload} />
              </label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.reversible} onChange={(e) => config.setReversible(e.target.checked)} /> Reversible</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.centered} onChange={(e) => config.setCentered(e.target.checked)} /> Centered</label>
            </div>
            <div>
              <label><input type="checkbox" checked={config.hideable} onChange={(e) => config.setHideable(e.target.checked)} /> Hideable</label> - <span>once revealed, content can be hidden</span>
            </div>
          </div>
        );
      }

      /**
       * Table editor component
       */
      function TableEditor({ entries, onChange, onAddEntry, onGroupEntries, onIsolateEntries, onMoveUp, onMoveDown, onRemoveEntries }) {
        const [selectAllChecked, setSelectAllChecked] = React.useState(false);
        const [selectAllIndeterminate, setSelectAllIndeterminate] = React.useState(false);

        const handleSelectAll = (e) => {
          const checked = e.target.checked;
          setSelectAllChecked(checked);
          setSelectAllIndeterminate(false);
          entries.forEach((group, groupIndex) => {
            group.forEach((entry, entryIndex) => {
              onChange(`${groupIndex}-${entryIndex}`, 'selected', checked);
            });
          });
        };

        const handleHighlight = (id, value) => onChange(id, 'highlighted', value);

        React.useEffect(() => {
          const totalEntries = entries.flat().length;
          const selectedEntries = entries.flat().filter(entry => entry.selected).length;

          if (selectedEntries === 0) {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(false);
          } else if (selectedEntries === totalEntries) {
            setSelectAllChecked(true);
            setSelectAllIndeterminate(false);
          } else {
            setSelectAllChecked(false);
            setSelectAllIndeterminate(true);
          }
        }, [entries]);

        return (
          <div>
            <h2>Entries</h2>
            <table>
              <thead>
                <tr>
                  <th>
                    <input
                      type="checkbox"
                      checked={selectAllChecked}
                      ref={el => el && (el.indeterminate = selectAllIndeterminate)}
                      onChange={handleSelectAll}
                    />
                  </th>
                  <th>Label</th>
                  <th>Content</th>
                  <th>PosX (%)</th>
                  <th>PosY (%)</th>
                  <th>Width (%)</th>
                  <th>Height (%)</th>
                </tr>
              </thead>
              {entries.map((entry, groupIndex) => (
                <tbody key={groupIndex}>
                  {entry.map((entry, index) => (
                    <TableEditorEntry
                      key={index}
                      id={`${groupIndex}-${index}`}
                      {...entry}
                      onChange={onChange}
                      onHighlight={(value) => handleHighlight(`${groupIndex}-${index}`, value)}
                    />
                  ))}
                </tbody>
              ))}
              <tfoot>
                <tr><td colSpan="8">
                  <span>{entries.flat().filter(entry => entry.selected).length} rows selected - </span>
                  <button onClick={onGroupEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Group</button>
                  <button onClick={onIsolateEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Isolate</button>

                  <button onClick={onMoveUp} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Move Up</button>
                  <button onClick={onMoveDown} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Move Down</button>

                  <button onClick={onRemoveEntries} disabled={entries.flat().filter(entry => entry.selected).length === 0}>Remove</button>

                  <button onClick={onAddEntry}>Add</button>
                </td></tr>
              </tfoot>
            </table>
          </div>
        );
      }

      /**
       * Generate options string from config
       */
      function generateOptionsString(config) {
        return ['reversible', 'centered', 'hideable'].filter(option => config[option]).join(' ');
      }

      /**
       * Visual editor component
       */
      function VisualEditor({ entries, config, htmlContent, onEntryUpdate }) {
        // Raw CSS used by advanced reveal features
        const revealCSS = `
          /****** REVEAL FUNCTIONALITY ******/
          /* USAGE

          - Add an image with class "reveal-background":

          <img class="reveal-background" src="{{Src}}">

          - For each reveal element, add the following HTML:

          <div class="reveal {{hint round border centered}}" style="top: {{Top}}; left: {{Left}}; height: {{Height}}; width: {{Width}};">
            <input id="{{ID}}" type="checkbox"></input>
            <label for="{{ID}}">{{Label}}</label>
            <div>{{Content}}</div>
          </div>

          - A generator is available at https://docs.google.com/spreadsheets/d/10xOEICIvBzzAa8FtoUb2MYhJlJLE-AfpuX9IoUlIQ0I/edit?usp=sharing

          - If not used in a reveal card type, manually add the following HTML around reveal items:

          <div class="reveal-container {{revealed centered reversible hideable front/back-gradient/transparent front/back-text-white/red}}">{...}</div>

          */

          .reveal-container {
              position: relative;
              margin: 0;
              padding: 0;
              user-select: none;
          }

          .reveal-container .reveal-background {
              display: block;
              width: 100%;
              height: auto;
          }
          .reveal-container img.reveal-background {
              max-width: 100%;
          }

          .reveal-container > :not(.reveal-background):not(.reveal-sequencing):not(.reveal) {
              display: none;
          }

          .reveal-container .reveal {
              position: absolute;
              margin: 0;
              padding: 0;
              z-index: 1;
          }

          .reveal-container .reveal > input {
              margin-left:-99999px;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div
          {
              display: flex;
              position: absolute;
              top: 0;
              left: 0;
              height: 100%;
              width: 100%;
              z-index: 1;
          }

          /* NOT CHECKED */

          .reveal-container:not(.revealed) .reveal:not(.revealed) > input:not(:checked) + label + div,
          .reveal-container .reveal.revealed > input:checked + label + div,
          .reveal-container.revealed .reveal > input:checked + label + div
          {
              display: none;
          }

          /* CHECKED or REVEALED */

          .reveal-container:not(.revealed) .reveal:not(.revealed) > input:checked + label,
          .reveal-container .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked) + label
          {
              opacity: 0;
          }

          .reveal-container:not(.revealed) .reveal:not(.revealed) .on-reveal {
            display: none;
          }

          /* DEFAULT LOOK */

          .reveal-container .reveal * {
              box-sizing: border-box;
              -moz-box-sizing: border-box;
              -webkit-box-sizing: border-box;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div {
              outline: none;
              justify-content: center;
              align-items: center;
              text-align: center;
              font-size: 2.5vw;
              background: white;
              border: none;
          }

          .reveal-container .reveal > input + label,
          .reveal-container .reveal > input + label + div,
          .reveal-container .reveal > input + label.text-black,
          .reveal-container .reveal.front-text-black > input + label,
          .reveal-container.front-text-black .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-black,
          .reveal-container .reveal.back-text-black > input + label + div,
          .reveal-container.back-text-black .reveal > input + label + div
          {
              color: black;
              text-shadow: -1px -1px 1px white, 1px -1px 1px white, -1px 1px 1px white, 1px 1px 1px white;
          }

          /* ADDITIONAL LOOKS */
          .reveal-container .reveal > input + label.gradient,
          .reveal-container .reveal.front-gradient > input + label,
          .reveal-container.front-gradient .reveal > input + label,
          .reveal-container .reveal > input + label + div.gradient,
          .reveal-container .reveal.back-gradient > input + label + div,
          .reveal-container.back-gradient .reveal > input + label + div
          {
              background: radial-gradient(circle, white, transparent);
              border: none;
          }

          .reveal-container .reveal > input + label.transparent,
          .reveal-container .reveal.front-transparent > input + label,
          .reveal-container.front-transparent .reveal > input + label,
          .reveal-container .reveal > input + label + div.transparent,
          .reveal-container .reveal.back-transparent > input + label + div,
          .reveal-container.back-transparent .reveal > input + label + div
          {
              background: transparent;
              border: none;
          }

          .reveal-container .reveal > input + label.text-white,
          .reveal-container .reveal.front-text-white > input + label,
          .reveal-container.front-text-white .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-white,
          .reveal-container .reveal.back-text-white > input + label + div,
          .reveal-container.back-text-white .reveal > input + label + div
          {
              color: white;
              text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
          }

          .reveal-container .reveal > input + label.text-red,
          .reveal-container .reveal.front-text-red > input + label,
          .reveal-container.front-text-red .reveal > input + label,
          .reveal-container .reveal > input + label + div.text-red,
          .reveal-container .reveal.back-text-red > input + label + div,
          .reveal-container.back-text-red .reveal > input + label + div
          {
              color: red;
              text-shadow: -1px -1px 1px black, 1px -1px 1px black, -1px 1px 1px black, 1px 1px 1px black;
          }

          /* CENTERED feature */

          .reveal-container .reveal.centered,
          .reveal-container.centered .reveal:not(.not-centered)
          {
              transform: translateX(-50%) translateY(-50%);
          }

          /* SEQUENCING feature */

          .reveal-container .reveal-sequencing {
            background: transparent;
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 100%;
            z-index: 1;
            display: none;
          }

          .reveal-container:not(.revealed) .reveal-sequencing:has(~ .reveal:not(.revealed) > input:not(:checked) + label)
          {
            display: block;
          }

          /* REVERSIBLE feature */

          .reveal-container .reveal > input:checked + label.reversible,
          .reveal-container .reveal.reversible > input:checked + label,
          .reveal-container.reversible .reveal > input:checked + label,
          .reveal-container .reveal.revealed > input:not(:checked)+ label.reversible,
          .reveal-container .reveal.revealed.reversible > input:not(:checked) + label,
          .reveal-container.reversible .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked)+ label.reversible,
          .reveal-container.revealed .reveal.reversible > input:not(:checked) + label,
          .reveal-container.revealed.reversible .reveal > input:not(:checked) + label
          {
              z-index: 2;
          }

          /* HIDEABLE feature */

          .reveal-container .reveal.revealed > input:not(:checked)+ label.hideable,
          .reveal-container .reveal.revealed.hideable > input:not(:checked) + label,
          .reveal-container.hideable .reveal.revealed > input:not(:checked) + label,
          .reveal-container.revealed .reveal > input:not(:checked)+ label.hideable,
          .reveal-container.revealed .reveal.hideable > input:not(:checked) + label,
          .reveal-container.revealed.hideable .reveal > input:not(:checked) + label
          {
              z-index: 2;
          }

          .reveal-container .reveal.revealed > input:checked + label.hideable,
          .reveal-container.revealed .reveal > input:checked + label.hideable,
          .reveal-container .reveal.revealed.hideable > input:checked + label,
          .reveal-container.revealed .reveal.hideable > input:checked + label,
          .reveal-container.hideable .reveal.revealed > input:checked + label,
          .reveal-container.revealed.hideable .reveal > input:checked + label
          {
              opacity: 0;
          }
        `;
        const [revealed, setRevealed] = React.useState(false);
        const [highlightedId, setHighlightedId] = React.useState(null);

        const handleMouseEnter = (id) => setHighlightedId(id);
        const handleMouseLeave = () => setHighlightedId(null);

        const handleDragStart = (e, id) => {
          console.log('DRAG', id);
          e.dataTransfer.setData("entryId", id);
        };

        const handleDrop = (e) => {
          e.preventDefault();
          const entryId = e.dataTransfer.getData("entryId");
          console.log('DROP', entryId);
          const container = e.currentTarget;
          const rect = container.getBoundingClientRect();

          const posX = ((e.clientX - rect.left) / rect.width) * 100;
          const posY = ((e.clientY - rect.top) / rect.height) * 100;

          onEntryUpdate(entryId, { posX: posX.toFixed(2), posY: posY.toFixed(2) });
        };

        const handleDragOver = (e) => {
          const entryId = e.dataTransfer.getData("entryId");
          console.log('DRAG-OVER', entryId);
          e.preventDefault();
        };

        return (
          <div id="visual-editor">
            <style>{revealCSS}</style>
            <h2>Visual Editor</h2>

            <div>
              <label><input type="checkbox" onChange={(e) => setRevealed(e.target.checked)} /> Reveal</label>
            </div>
            
            <div
              className={`reveal-container ${revealed ? 'revealed' : ''} ${generateOptionsString(config)}`}
              onDrop={handleDrop}
              onDragOver={handleDragOver}
            >
              <img className="reveal-background" src={config.backgroundImage} />
              {entries.slice().reverse().map((group, groupIndex) => (
              <React.Fragment key={groupIndex}>
                {group.slice().reverse().map((entry, entryIndex) => {
                  const id = `${entries.length - groupIndex - 1}-${group.length - entryIndex - 1}`;
                  const isHighlighted = highlightedId === id || entry.selected || entry.highlighted;
                  return (
                    <div
                      key={entryIndex}
                      className={`reveal ${isHighlighted ? 'highlight' : ''}`}
                      style={{ left: `${entry.posX}%`, top: `${entry.posY}%`, width: `${entry.width}%`, height: `${entry.height}%` }}
                      draggable
                      onDragStart={(e) => handleDragStart(e, id)}
                      onMouseEnter={() => handleMouseEnter(id)}
                      onMouseLeave={handleMouseLeave}
                    >
                      <input id={id} type="checkbox" />
                      <label htmlFor={id} dangerouslySetInnerHTML={{ __html: entry.label }} />
                      <div dangerouslySetInnerHTML={{ __html: entry.content }} />
                    </div>
                  );
                })}
                {groupIndex < entries.length - 1 && <div className="reveal-sequencing"></div>}
              </React.Fragment>
              ))}
            </div>
          </div>
        );
      }

      /**
       * HTML editor component
       */
      function HtmlEditor({ config, htmlContent }) {
        return (
          <div id="html-editor">
            <h2>ANKI Card - HTML Output</h2>

            <label>Options:</label>
            <input type="text" value={generateOptionsString(config)} style={{ width: '100%' }} disabled />
            
            <label>Back:</label>
            <textarea style={{ width: '100%', height: '200px' }} value={htmlContent} disabled></textarea>
          </div>
        )
      }

      function MyApp() {
        const defaultEntries = [];
        const initEntries = [
          [
            { selected: false, highlighted: false, label: "LABEL", content: "CONTENT", posX: "50", posY: "50", width: "20", height: "10" },
          ],
        ];

        const initBackgroundImage = "";
        const defaultConfig = {
          reversible: true,
          centered: true,
          hideable: false,
          backgroundImage: "",
          setReversible: (value) => setConfig((prevConfig) => ({ ...prevConfig, reversible: value })),
          setCentered: (value) => setConfig((prevConfig) => ({ ...prevConfig, centered: value })),
          setHideable: (value) => setConfig((prevConfig) => ({ ...prevConfig, hideable: value })),
          setBackgroundImage: (value) => setConfig((prevConfig) => ({ ...prevConfig, backgroundImage: value }))
        };

        const [entries, setEntries] = React.useState(initEntries);
        const [config, setConfig] = React.useState({...defaultConfig, backgroundImage: initBackgroundImage});

        const [htmlContent, setHtmlContent] = React.useState();

        React.useEffect(() => {
          const revealContainer = document.querySelector('#visual-editor .reveal-container');
          if (revealContainer) {
            setHtmlContent(revealContainer.innerHTML.replace(/(\<div\s+[^>]*class="([^"]*\s+)?reveal(-sequencing)?(\s+[^"]*)?"[^>]*>)/g, '\n\n$1'));
          }
        }, [entries, config]);

        const handleReset = () => {
          setEntries(defaultEntries);
          setConfig(defaultConfig);
        };

        const handleExport = () => {
          navigator.clipboard.writeText(htmlContent).then(() => {
            alert('Exported to clipboard!');
          }).catch(err => {
            console.error('Failed to copy: ', err);
          });
        };

        const handleEntryChange = (id, field, value) => {
          handleEntryUpdate(id, {[field]: value});
        };

        const handleEntryUpdate = (id, updatedFields) => {
          setEntries(prevEntries =>
            prevEntries.map((group, groupIndex) =>
              group.map((entry, entryIndex) => {
                const entryId = `${groupIndex}-${entryIndex}`;
                return entryId === id ? { ...entry, ...updatedFields } : entry;
              })
            )
          );
        };

        const handleAddEntry = () => {
          setEntries(prevEntries => {
            const newEntry = { selected: true, highlighted: false, label: "", content: "", posX: "50", posY: "50", width: "10", height: "10" };

            if (prevEntries.length === 0) {
              return [[newEntry]];
            }

            return prevEntries.map((group, index) => 
              index === prevEntries.length - 1 ? [...group, newEntry] : group
            );
          });
        };

        const handleGroupEntries = () => {
          setEntries(prevEntries => {
            const result = [];
            let prevSelected = undefined;
            let prevGroupId = undefined;

            prevEntries.forEach((group, groupId) => {
              group.forEach(entry => {
                if (entry.selected !== prevSelected || (!entry.selected && groupId !== prevGroupId)) {
                  result.push([]);
                  prevSelected = entry.selected;
                  prevGroupId = groupId;
                }
                result[result.length - 1].push({...entry});
              });
            });

            return result;
          });
        };

        const handleIsolateEntries = () => {
          setEntries(prevEntries => {
            const result = [];
            let prevSelected = undefined;
            let prevGroupId = undefined;

            prevEntries.forEach((group, groupId) => {
              group.forEach(entry => {
                if (entry.selected || (!entry.selected && prevSelected) || groupId !== prevGroupId) {
                  result.push([]);
                  prevSelected = entry.selected;
                  prevGroupId = groupId;
                }
                result[result.length - 1].push({...entry});
              });
            });

            return result;
          });
        };

        const handleRemoveEntries = () => {
          setEntries(prevEntries =>
            prevEntries.map(group =>
              group.filter(entry => !entry.selected)
            ).filter(group => group.length > 0)
          );
        };

        const  handleMoveDown = () => {
          setEntries(prevEntries => {
            const result = [];
            let preventMoving = false;

            prevEntries.reverse().forEach((group, groupId) => {
              const newGroup = [];

              group.reverse().forEach(entry => {
                if (newGroup.length == 0) {
                  // First entry in the group
                  if (groupId == 0) {
                    // Last group, unable to move down, prevent further moving if selected
                    newGroup.push(entry);
                    preventMoving = entry.selected;
                  } else if(entry.selected && !preventMoving) {
                    // Overlap with previous group
                    result[0].unshift(entry);
                  } else {
                    newGroup.push(entry);
                  }
                } else if(entry.selected && !preventMoving) {
                  // Move entry inside the group
                  newGroup.splice(1, 0, entry);
                } else {
                  // Keep entry in the same position
                  newGroup.unshift(entry);
                }
              });
              result.unshift(newGroup);
            });

            return result.filter(group => group.length > 0);
          });
        };

        const  handleMoveUp = () => {
          setEntries(prevEntries => {
            const result = [];
            let preventMoving = false;

            prevEntries.forEach((group, groupId) => {
              const newGroup = [];

              group.forEach(entry => {
                if (newGroup.length == 0) {
                  // First entry in the group
                  if (groupId == 0) {
                    // First group, unable to move up, prevent further moving if selected
                    newGroup.push(entry);
                    preventMoving = entry.selected;
                  } else if(entry.selected && !preventMoving) {
                    // Overlap with previous group
                    result[result.length-1].push(entry);
                  } else {
                    newGroup.push(entry);
                  }
                } else if(entry.selected && !preventMoving) {
                  // Move entry inside the group
                  newGroup.splice(-1, 0, entry);
                } else {
                  // Keep entry in the same position
                  newGroup.push(entry);
                }
              });
              result.push(newGroup);
            });

            return result.filter(group => group.length > 0);
          });
        };

        return (
          <>
            <h1>Anki - Card-reveal Editor</h1>
            <Toolbar onReset={handleReset} onExport={handleExport} />
            <TableEditor entries={entries} onChange={handleEntryChange} onAddEntry={handleAddEntry} onGroupEntries={handleGroupEntries} onIsolateEntries={handleIsolateEntries} onMoveUp={handleMoveUp} onMoveDown={handleMoveDown} onRemoveEntries={handleRemoveEntries} />
            <Config config={config} />
            <VisualEditor entries={entries} config={config} htmlContent={htmlContent} onEntryUpdate={handleEntryUpdate} />
            <HtmlEditor config={config} htmlContent={htmlContent} />
          </>
        );
      }

      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<MyApp />);

    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      Read this page for starting a new React project with JSX:
      https://react.dev/learn/start-a-new-react-project

      Read this page for adding React with JSX to an existing project:
      https://react.dev/learn/add-react-to-an-existing-project
    -->
  </body>
</html>